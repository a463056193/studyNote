> 以一次数据的读取为例，应用程序是没有办法直接操纵硬件设备的，只有通过内核才能跟硬件交互。当网卡接收到数据之后，此时数据在网卡中，需要内核将网卡中的数据读取到内核空间中，再从内核空间拷贝到用户空间，这个时候应用程序才拿到数据，读取数据结束。

一次IO的过程必然会有三个角色的参与

1. 应用程序
2. 内核
3. 数据

### 同步阻塞模型

应用程序发起了一个IO请求（以读取数据为例），此时需要进行一次系统调用，内核由用户态切换到内核态，内核开始跟硬件设备进行交互并从硬件设备中读取数据，此时可能硬件设备还没有接收到数据，所以内核函数一直阻塞，直到数据到达才进行返回

### 同步非阻塞

当应用程序发起了一次读取数据的请求，还是会发起系统调用，但是此时内核根据硬件中是否有数据执行不同的操作，如果有数据，那么将数据拷贝到用户空间，如果没有数据也会返回一个标志，比如-1，应用程序在轮询期间并没有一直阻塞，而是可以进行执行。



### 异步非阻塞

应用程序只需要发起一次读取数据的请求，接下来就等着内核将数据拷贝到用户空间，并且内核将数据拷贝完成后会通知应用程序，在整个过程中程序可以继续往下执行



- 阻塞/非阻塞：描述的是调用者调用方法后的状态，比如：线程A调用了B方法，A线程处于阻塞状态。
- 同步/异步：描述的方法跟调用者间通信的方式，如果不需要调用者主动等待，调用者调用后立即返回，然后方法本身通过回调，消息通知等方式通知调用者结果，就是异步的。如果调用方法后一直需要调用者一直等待方法返回结果，那么就是同步的