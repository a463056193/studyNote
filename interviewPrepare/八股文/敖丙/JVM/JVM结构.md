### 数据类型

jvm包含两种数据类型，基本类型和引用类型

**基本类型**

1. 数值类型：整型，浮点型，char类型
2. boolean：true，false
3. returnAddress：指针，指向jvm指令的操作码，在Java中没有与之对应的类型

boolean类型的操作会被转换为int类型的操作进行，boolean数组会被当成byte数组

**引用类型**

它们的值是动态创建的类实例，数组，或实现接口的类实例



### 运行时公有数据区

**堆**

jvm有一个堆，在所有jvm线程间共享，堆是一个运行时数据区域，所有为类实例和数组分配的内存都来自于它

堆在jvm启动时创建，堆中对象不用显示释放，gc会帮我们释放并回收内存

**方法区**

jvm有一个方法区，在所有jvm线程间共享，它存储每一个类的结构

运行时常量池，字段和方法数据，方法和构造函数的代码，还有特殊的方法用于类和实例的初始化，还有接口的初始化

方法区在jvm启东市创建，虽然方法区在逻辑上是堆的一部分

但简单实现时可以选择不进行gc和压缩，没有规范强制要求方法区的位置，也没有要求管理已编译代码的策略

**运行时常量池**

运行时常量池就是类和接口的字节码文件里的常量池的运行时表示形式，它包含几种敞亮

如在编译时就已经知道的数字字面量值，和必须在运行时解析的方法和字段的引用，运行时常量池的功能类似于传统语言的符号表，不过它包含的数据会更加宽泛。

运行时常量池分配在jvm的方法区，类或接口的运行时常量池在类或接口被jvm创建时才会构建。



### **运行时私有数据区**

**pc寄存器**

jvm支持一次运行多个线程，每个线程都有自己的pc寄存器，任何时候一个线程只能运行一个方法的代码。

如果方法不是native的，pc寄存器包含当前正在被执行的jvm指令地址，如果方法是native的，pc寄存器的值是未定义的。

**jvm栈**

每一个jvm线程都有一个私有的jvm栈，随着线程的创建而创建，栈中存储的是帧。

jvm栈和传统语言如C的栈相似，保存局部变量和部分计算结果，参与方法的调用和返回。jvm栈主要用于帧的出栈和入栈，除此之外没有其它操作，

帧可能是在堆上分配的，所以jvm栈使用的内存不必是连续的。

**native方法栈**

native方法不是用Java语言写的，为了支持它需要使用传统栈，如C语言栈。不过jvm不能加载native方法，所以也不需要提供native方法需要的栈。



**帧**

每次当一个方法被调用时一个新的帧会被创建。当方法调用完成时，与之对应的帧会被销毁，无论是正常完成还是抛异常结束。

所以帧是方法调用的具体体现形式，或称方法调用是以帧的形式进行的。帧用来存储数据和部分计算结果，和执行动态链接，方法返回值，分发异常。

帧分配在创建帧的线程的jvm栈上，每一个帧都有自己的本地变量数组，自己的操作数栈，和一个对当前方法所在类的运行时常量池的引用。

本地变量数组和操作数栈的大小在编译时就确定了，它们随着和帧关联的方法编译后的代码一起被提供，因此帧这种数据结构的大小只依赖于jvm的实现，这些结构所需的内存可以在方法调用时同时被分配。

在一个线程执行的任何时刻，都只会有一个帧是处于激活的。这个帧被称为当前帧，与之对应的方法被称为当前方法，方法所在的类被称为当前类，此时用到的本地变量数组和操作数栈也都是当前帧的。

一个帧将不在继续是当前帧，如果它的方法调用了另一个方法，或者它的方法结束了。

当一个方法被调用，一个新的帧被创建，当执行控制由原来的方法传递到新的方法时，这个新的帧变为当前帧。

当方法返回时，当前帧把方法执行的结果传回到上一帧，当上一帧被激活的同时当前帧会被丢弃。

**本地变量数组**

每一帧都包含一个变量数组，就是都熟知的本地变量存储的地方。这个本地变量数组的长度在编译时确定，随着编译后的方法代码一起提供。

通常一个本地变量（的位置）能够存储一个类型的值，但是long和double类型却需要两个本地变量（的位置）才能存一个值。

本地变量按索引寻址，第一个本地变量的索引是0。long和double需要消耗两个连续的索引，但却是按照较小的这个索引寻址的。不能按照较大的那个索引去读数据，但是可以写入，当然这样将使本地变量内容错乱。

在方法被调用时，jvm使用本地变量来接收传递进来的参数值。在类（静态）方法调用时，所有参数被传入从索引0开始的连贯的本地变量数组里。

在实例（非静态）方法调用时，索引0处总是传入正在其上执行方法调用的那个对象的引用，（就是Java中的this了），所有参数被传入从1开始的连贯的本地变量数组里。

**操作数栈**

每个帧包含一个后进先出的栈，用于存储正在执行的jvm指令的操作数，就是都熟知的操作数栈，这个栈的最大深度在编译时就已确定，随着编译后的方法代码一起提供。

当帧被创建时，操作数栈是空的，jvm提供一些指令用于加载常量值，本地变量值，字段值到操作数栈上，另一些jvm指令采用操作数栈上的操作数进行操作，并把结果放回到操作数栈上。

操作数栈也用于准备将要传递给方法调用的参数和接收方法调用返回的结果。

long和double类型的值占用两个单位的栈深度，其它类型的值占用一个单位的栈深度。



**动态链接**

每一个帧都包含了对当前方法所属类型的运行时常量池的引用。目的是为了支持方法代码的动态链接。class文件中描述一个方法引用被调用的方法和被访问的变量的代码，是采用符号引用的形式实现的。

符号引用的形式可以粗略的认为是字符串的形式，就是用字符串标明需要调用哪个类的哪个方法或访问哪个字段或变量。就像符号引用这个名字一样，这些仅仅是符号，是拿不到具体值的，所以必须要进行转换。

动态链接就是把这些符号方法引用转换为具体的方法引用，在必要时加载类来解析尚未明确的符号，把符号变量的访问转换为这些变量运行时所在存储结构的适合的偏移量（索引）。这样的方式又称为后期绑定。



**方法调用**

一个方法调用正常完成（即没有抛异常）时，会根据所返回的值的类型执行一个适合的return指令，当前帧会去恢复调用者的状态，包括它的本地变量和操作数栈，使调用者的程序计数器适合的递增来跳过刚刚的那个方法调用指令。

返回值会被放到调用者帧的操作数栈上，然后继续执行调用者方法的帧。

一个方法在调用时抛出了异常，且这个异常没有在这个方法内被捕获处理，将会导致这个方法调用的突然结束，这种情况下永远不会向方法的调用者返回一个值。





